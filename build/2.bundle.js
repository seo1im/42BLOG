(window.webpackJsonp=window.webpackJsonp||[]).push([[2],{32:function(s,n){s.exports={attributes:{Category:"Libft",Id:1,Title:"Libft 개요",Description:"Libft 프로젝트에 대한 기본적인 내용",Date:"2020, 10, 16 (Fri)",Auther:"seolim",pre:0,next:2},html:'<h1>Libft 개요</h1>\n<blockquote>\n<p>Link</p>\n</blockquote>\n<p><a href="https://github.com/seo1im/Libft">https://github.com/seo1im/Libft</a></p>\n<blockquote>\n<p>Caution</p>\n</blockquote>\n<p>본 문서를 포함한 블로그의 모든 내용은 <b>42 innovation academy</b>의 과제의 작성자의 해석 및 풀이 등으로 이루어져 있습니다.</br>본인이 42 교육생이거나 42 교육을 희망하는 분이라면 글을 먼저 보기보다는 고민해보고 읽어보기를 추천드립니다.</br></br></p>\n<blockquote>\n<p>목적</p>\n</blockquote>\n<p>Libft는 c library중 <code>&lt;string.h&gt;</code>, <code>&lt;stdlib.h&gt;</code>, <code>&lt;ctype.h&gt;</code>에 포함된 함수를 직접 구현하고 custom library로 compile해보는 과제이다.</br></br>해당 과제에서 필수로 구현해야 하는 함수들은 아래와 같다.</p>\n<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">memset</span> <span class="hljs-params">(<span class="hljs-keyword">void</span>* ptr, <span class="hljs-keyword">int</span> value, <span class="hljs-keyword">size_t</span> num )</span></span>;\n\n<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bzero</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *s, <span class="hljs-keyword">size_t</span> n)</span></span>;\n\n<span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">memcpy</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* destination, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* source, <span class="hljs-keyword">size_t</span> num)</span></span>;\n\n<span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">memccpy</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *dest, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *src, <span class="hljs-keyword">int</span> c, <span class="hljs-keyword">size_t</span> n)</span></span>;\n\n<span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">memmove</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* destination, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* source, <span class="hljs-keyword">size_t</span> num)</span></span>;\n\n<span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">memchr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* ptr, <span class="hljs-keyword">int</span> value, <span class="hljs-keyword">size_t</span> num)</span></span>;\n\n<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">memcmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* ptr1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* ptr2, <span class="hljs-keyword">size_t</span> num)</span></span>;\n\n<span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">strlen</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* str)</span></span>;\n\n<span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">strlcpy</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* dst, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* src, <span class="hljs-keyword">size_t</span> size)</span></span>;\n\n<span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">strlcat</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* dst, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* src, <span class="hljs-keyword">size_t</span> size)</span></span>;\n\n<span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">strchr</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* str, <span class="hljs-keyword">int</span> character)</span></span>;\n\n<span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">strrchr</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* str, <span class="hljs-keyword">int</span> character)</span></span>;\n\n<span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">strnstr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *big, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *little, <span class="hljs-keyword">size_t</span> len)</span></span>;\n\n<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">strncmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* str1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* str2, <span class="hljs-keyword">size_t</span> num)</span></span>;\n\n<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">atoi</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* str)</span></span>;\n\n<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isalpha</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span></span>;\n\n<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isdigit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span></span>;\n\n<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isalnum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span></span>;\n\n<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isascii</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span></span>;\n\n<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isprint</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span></span>;\n\n<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">toupper</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span></span>;\n\n<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">tolower</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span></span>;\n\n<span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">calloc</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> elt_count, <span class="hljs-keyword">size_t</span> elt_size)</span>\n\n<span class="hljs-keyword">char</span>* <span class="hljs-title">strdup</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* str)</span></span>;\n</code></pre>\n<p>Piscine을 통과한 교육생이라면 이미 작성해보았거나 한번쯤 보았던 함수들이 있을 것이다. 해당 과제에선 각각의 함수를 이해해보고 이러한 함수들이 언제 어디에서 사용될 수 있을지 생각해보는 과정을 가지도록 하자.</p>\n'}},33:function(s,n){s.exports={attributes:{Category:"Libft",Id:2,Title:"Libft : mem function",Description:"mem function",Date:"2020, 10, 16 (Fri)",Auther:"seolim",pre:1,next:3},html:'<h1>Libft mem function</h1>\n<blockquote>\n<p>Link</p>\n</blockquote>\n<p><a href="https://github.com/seo1im/Libft">https://github.com/seo1im/Libft</a></p>\n<blockquote>\n<p>Caution</p>\n</blockquote>\n<p>본 문서를 포함한 블로그의 모든 내용은 <b>42 innovation academy</b>의 과제의 작성자의 해석 및 풀이 등으로 이루어져 있습니다.</br>본인이 42 교육생이거나 42 교육을 희망하는 분이라면 글을 먼저 보기보다는 고민해보고 읽어보기를 추천드립니다.</p>\n<blockquote>\n<p>목적</p>\n</blockquote>\n<p>mem 관련 함수들을 알아보자. 이번 과정에서 알아볼 함수들은 아래와 같다.</p>\n<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">memset</span> <span class="hljs-params">(<span class="hljs-keyword">void</span>* ptr, <span class="hljs-keyword">int</span> value, <span class="hljs-keyword">size_t</span> num )</span></span>;\n\n<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bzero</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *s, <span class="hljs-keyword">size_t</span> n)</span></span>;\n\n<span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">memcpy</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* destination, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* source, <span class="hljs-keyword">size_t</span> num)</span></span>;\n\n<span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">memccpy</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *dest, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *src, <span class="hljs-keyword">int</span> c, <span class="hljs-keyword">size_t</span> n)</span></span>;\n\n<span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">memmove</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* destination, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* source, <span class="hljs-keyword">size_t</span> num)</span></span>;\n\n<span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">memchr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* ptr, <span class="hljs-keyword">int</span> value, <span class="hljs-keyword">size_t</span> num)</span></span>;\n\n<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">memcmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* ptr1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* ptr2, <span class="hljs-keyword">size_t</span> num)</span></span>;\n</code></pre>\n<blockquote>\n<p>mem 함수들</p>\n</blockquote>\n<p>mem함수는 메모리를 조작하는 함수들이며 <code>&lt;string.h&gt;</code>에 정의되어있다.(정확히는 memset, memcmp등은 <code>&lt;memory.h&gt;</code>에 정의되어 있으며 <code>&lt;string.h&gt;</code>에서 include 되어있다)</br></br>\nmem함수들은 모두 사이즈(<code>size_t</code>)를 파라미터로 받는데, 문자열과 같이 마지막이 null문자라는 규칙같은게 없기 때문에 메모리의 마지막을 판단 할 수 없기 때문이다.</br></br>mem함수들은 string에 정의되어있기는 하지만 pointer면 어떤값이든 받아서 동작할 수 있다. 아래와 같이 int 배열에서도 동작한다.</p>\n<pre class="hljs"><code><span class="hljs-keyword">int</span> nums[<span class="hljs-number">3</span>] = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>};\n<span class="hljs-keyword">int</span> copy[<span class="hljs-number">3</span>];\n\n<span class="hljs-built_in">memcpy</span>(copy, nums, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * <span class="hljs-number">3</span>);\n<span class="hljs-comment">/* int 배열은 한칸당 4bit의 크기를 가지기 때문에 위 같은 배열에선 12(sizeof(int) * 3)만큼의 크기를 복사해야 정상적으로 동작함을 꼭 기억하자\n</span></code></pre>\n<h3>memset</h3>\n<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">memset</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* ptr, <span class="hljs-keyword">int</span> value, <span class="hljs-keyword">size_t</span> num)</span></span>;\n</code></pre>\n<table>\n    <tr>\n        <td class="title">ptr</td>\n        <td>메모리 블럭의 첫번째 주소</td>\n    </tr>\n    <tr>\n        <td class="title">value</td>\n        <td>할당할 값</td>\n    </tr>\n    <tr>\n        <td class="title">num</td>\n        <td>할당할 크기</td>\n    </tr>\n    <tr>\n        <td class="title">return</td>\n        <td>성공 : ptr / 실패 : NULL</td>\n    </tr>\n</table>\n<p>메모리 블럭(ptr)에 특정 값(value)를 특정 길이(size)만큼 할당한다. 성공하면 ptr을 반환하고 실패하면 NULL을 반환한다.</p>\n<p>주로 초기화를 할 때 사용한다. 예를 들어 아래와 같이 활용한다.</p>\n<pre class="hljs"><code><span class="hljs-keyword">char</span>  ptr[<span class="hljs-number">10</span>];\n\n<span class="hljs-built_in">memset</span>(ptr, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>);\n</code></pre>\n<p>위 코드가 실행되면 배열 ptr의 모든 값은 0으로 초기화 된다.</p>\n<h5>왜 필요할까?</h5>\n<p>일반적으로 배열의 할당은 위처럼 선언을 통해 할당하거나 malloc등의 allocation함수를 통해 메모리를 할당한다. 해당 할당은 그저 일정 메모리를 변수에 할당해 주는것이기 때문에 그 값이 일정치 않다. 그러한 값을 쓰레기값(garbage value)라 한다. memset을 통해 최초의 값들을 모두 null값(0)등으로 초기화하여 에러를 방지한다.</p>\n<h3>bzero</h3>\n<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bzero</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *s, <span class="hljs-keyword">size_t</span> n)</span></span>;\n</code></pre>\n<table>\n    <tr>\n        <td class="title">s</td>\n        <td>메모리 블럭의 첫번째 주소</td>\n    </tr>\n    <tr>\n        <td class="title">n</td>\n        <td>할당할 사이즈</td>\n    </tr>\n</table>\n<p>memset과 동일하게 동작하며 단 값이 모두 0이다. memset 예제와 동일하게 동작한다.</p>\n<h3>memcpy</h3>\n<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">memcpy</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* destination, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* source, <span class="hljs-keyword">size_t</span> num)</span></span>;\n</code></pre>\n<table>\n    <tr>\n        <td class="title">destination</td>\n        <td>복사될 메모리 시작점</td>\n    </tr>\n    <tr>\n        <td class="title">source</td>\n        <td>복사할 메모리 시작점</td>\n    </tr>\n    <tr>\n        <td class="title">num</td>\n        <td>복사할 크기</td>\n    </tr>\n    <tr>\n        <td class="title">return</td>\n        <td>destination</td>\n    </tr>\n</table>\n<p>지정된 크기만큼의 메모리의 값을 다른 메모리에 복사한다. 복사범위가 같으면 overflow문제가 발생할 수 있으며 관련내용은 <a href="">다음 글</a>을 참고하자</p>\n<h5>왜 필요할까?</h5>\n<p>포인터에 대한 이해가 명확하다면 값 복사가 왜 필요한지 알고 있을것이다. 아래 코드를 봤을 때, 결과가 어떻게 다를지를 생각해보자.</p>\n<pre class="hljs"><code><span class="hljs-keyword">char</span> str1[] = <span class="hljs-string">&quot;sample&quot;</span>;\n<span class="hljs-keyword">char</span> *str2;\n<span class="hljs-keyword">char</span> *str3;\n\nstr2 = str;\n<span class="hljs-built_in">memcpy</span>(str3, str, <span class="hljs-number">7</span>);\n<span class="hljs-comment">/* 위 코드는 str3에 메모리가 할당되지 않아 strict한 환경에선 동작하지 않는다. 동작시키려면 str3에 미리 크기 7 이상의 동적할당을 하도록 하자*/</span>\n</code></pre>\n<p>str2는 str1의 포인터를 그대로 할당받는다. 따라서 str1의 값이 변경되면 str2의 값도 함께 바뀐다. 즉 str1과 str2가 가르키고 있는 주소는 동일하다.</p>\n<h3>memccpy</h3>\n<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">memccpy</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *dest, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *src, <span class="hljs-keyword">int</span> c, <span class="hljs-keyword">size_t</span> n)</span></span>;\n</code></pre>\n<table>\n    <tr>\n        <td class="title">dest</td>\n        <td>복사될 메모리 시작점</td>\n    </tr>\n    <tr>\n        <td class="title">src</td>\n        <td>복사할 메모리 시작점</td>\n    </tr>\n    <tr>\n        <td class="title">c</td>\n        <td>복사를 멈출 플래그 문자</td>\n    </tr>\n    <tr>\n        <td class="title">n</td>\n        <td>복사할 메모리 크기</td>\n    </tr>\n    <tr>\n        <td class="title">return</td>\n        <td>desc</td>\n    </tr>\n</table>\n<p><code>memcpy</code>와 동일하나 정해준 특정 값(c)을 발견하면 복제를 멈춘다.</p>\n<h3>memmove</h3>\n<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">memmove</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* destination, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* source, <span class="hljs-keyword">size_t</span> num)</span></span>;\n</code></pre>\n<table>\n    <tr>\n        <td class="title">destination</td>\n        <td>복사될 메모리 시작점</td>\n    </tr>\n    <tr>\n        <td class="title">source</td>\n        <td>복사할 메모리 시작점</td>\n    </tr>\n    <tr>\n        <td class="title">num</td>\n        <td>복사할 크기</td>\n    </tr>\n    <tr>\n        <td class="title">return</td>\n        <td>destination</td>\n    </tr>\n</table>\n<p><code>memcpy</code>와 기능은 완전히 동일하다. 다만 메모리 중간에 버퍼를 이용해 <code>memcpy</code>의 overflow 문제는 없다. <a href="">다음 글</a>을 참고하자.</p>\n<h3>memchr</h3>\n<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">memchr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* ptr, <span class="hljs-keyword">int</span> value, <span class="hljs-keyword">size_t</span> num)</span></span>;\n</code></pre>\n<table>\n    <tr>\n        <td class="title">ptr</td>\n        <td>복사될 메모리 시작점</td>\n    </tr>\n    <tr>\n        <td class="title">value</td>\n        <td>찾을 값</td>\n    </tr>\n    <tr>\n        <td class="title">num</td>\n        <td>찾아볼 메모리 범위</td>\n    </tr>\n    <tr>\n        <td class="title">return</td>\n        <td>성공 : 일치되는 값의 주소 / 실패 : NULL</td>\n    </tr>\n</table>\n<p>주어진 메모리내에 원하는 특정값을 찾아 그 주소를 반환한다.</p>\n<h3>memcmp</h3>\n<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">memcmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* ptr1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* ptr2, <span class="hljs-keyword">size_t</span> num)</span></span>;\n</code></pre>\n<table>\n    <tr>\n        <td class="title">ptr1</td>\n        <td>비교 메모리 블록 시작점</td>\n    </tr>\n    <tr>\n        <td class="title">ptr2</td>\n        <td>비교 메모리 블록 시작점</td>\n    </tr>\n    <tr>\n        <td class="title">num</td>\n        <td>비교할 범위</td>\n    </tr>\n    <tr>\n        <td class="title">return</td>\n        <td>일치 : 0 / 불일치 : 다른값의 차(*ptr1 - *ptr2)</td>\n    </tr>\n</table>\n<p>두 메모리블록들의 값이 일치하는지를 비교하는 함수이다.</p>\n<h5>왜 필요할까?</h5>\n<p>메모리의 값을 비교하는데에 주의하면 된다. 아래 코드를 보자</p>\n<pre class="hljs"><code><span class="hljs-keyword">char</span> str1[] = <span class="hljs-string">&quot;test&quot;</span>;\n<span class="hljs-keyword">char</span> str2[] = <span class="hljs-string">&quot;test&quot;</span>;\n\n<span class="hljs-keyword">int</span> equl = str1 == str2 ;\n<span class="hljs-keyword">int</span> cmp = <span class="hljs-built_in">memcmp</span>(str1, str2, <span class="hljs-number">4</span>) == <span class="hljs-number">0</span>;\n<span class="hljs-comment">/*cmp는 값이 같으면 0을 반환하기 때문에 통일성을 위와 같이 작성하였다.*/</span>\n</code></pre>\n<p><code>eqaul</code>의 값은 0(<code>false</code>)이지만 <code>cmp</code>의 값은 1(<code>true</code>)이다. 포인터의 비교는 포인터의 주소가 동일한지 확인하는 것이기 때문에 위와같이 동작하게 된다. 앞서 말했던 값과 포인터의 차이를 잘 생각해보자.</p>\n'}},34:function(s,n){s.exports={attributes:{Category:"Libft",Id:3,Title:"Libft : memcpy와 memmove",Description:"memmove와 memcpy의 차이를 구별해보자",Date:"2020, 10, 19 (Mon)",Auther:"seolim",pre:2,next:4},html:'<h1>Libft memcpy memmove</h1>\n<blockquote>\n<p>Link</p>\n</blockquote>\n<p><a href="https://github.com/seo1im/Libft">https://github.com/seo1im/Libft</a></p>\n<blockquote>\n<p>Caution</p>\n</blockquote>\n<p>본 문서를 포함한 블로그의 모든 내용은 <b>42 innovation academy</b>의 과제의 작성자의 해석 및 풀이 등으로 이루어져 있습니다.</br>본인이 42 교육생이거나 42 교육을 희망하는 분이라면 글을 먼저 보기보다는 고민해보고 읽어보기를 추천드립니다.</p>\n<blockquote>\n<p>목적</p>\n</blockquote>\n<p>mem 함수들 중 유사한 함수인 memcpy와 memmove의 차이를 명확히 해보자</p>\n<h5>주의점</h5>\n<p>실제 환경에서 <code>memcpy</code>와 <code>memmove</code>를 아래 예제와 같이 진행하면 전혀 문제없이 동일한 결과가 나올 수 있다. 이는 현재 대부분의 환경에서 <code>memcpy</code>의 overlapping 문제를 해결했기 때문이다. 그러나 42 seoul의 물리넷을 포함한 일부 환경에선 아직 <code>memcpy</code>의 개선이 이루어지지 않았음을 알아두자.</p>\n<blockquote>\n<p>memcpy와 memmove</p>\n</blockquote>\n<p><code>memcpy</code> 와 <code>memmove</code>는 둘다 메모리의 값을 복사하는 함수이다. 실제로 기능적으로 두 함수는 전혀 차이가 없다.</br></br>두 함수의 차이는 <code>memcpy</code>는 메모리를 직접 copy를 진행하고 <code>memmove</code>는 값을 임시 버퍼에 저장한 후 복사를 진행한다. 아래 코드를 보자</p>\n<pre class="hljs"><code><span class="hljs-keyword">char</span> str[] = <span class="hljs-string">&quot;1234567890&quot;</span>\n\n<span class="hljs-built_in">memcpy</span>(str + <span class="hljs-number">1</span>, str, <span class="hljs-number">9</span>);\n\n<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\\n&quot;</span>, str);\n<span class="hljs-comment">/* result : 1111111111&quot; */</span>\n</code></pre>\n<p>위 코드와 같이 오버래핑(overlapping)이 발생한다. 아래 그림을 보면 이해가 될 것이다.</p>\n<h5>TODO : 그림 위치</h5>\n<p><code>memmove</code>는 이러한 문제를 해결하기 위해 임시 버퍼공간에 복사할 데이터를 이동한 후 복사를 진행한다. 따라서 위와같은 문제는 발생하지 않는다.</br></br>쉽게 생각해서 memcpy는 문제가 발생할 수 있지만 속도가 빠르고, memmove는 느리지만 안전하다.</p>\n<h3>memmove의 개선</h3>\n<p>memmove는 memcpy에 대비해서 느리다는것을 위에서 알았다. 그렇다면 memmove를 조금이라도 빠르게 하려면 어떻게 해야할까?</br></br>overlap이 발생하는 경우는 source가 destination 보다 앞선 경우(작은 경우)에 대해 발생할 수 있다. 따라서 해당 경우를 제외하고는 memcpy와 동일하게 동작하여도 아무런 문제가 없다.</p>\n<pre class="hljs"><code><span class="hljs-keyword">if</span> (dest &lt;= src)\n{\n    <span class="hljs-comment">/* cpy와 동일하게 직접 복사 */</span>\n}\n<span class="hljs-keyword">else</span>\n{\n    <span class="hljs-comment">/* 임시버퍼에 저장하거나 뒤에서 부터 복사 */</span>\n}\n</code></pre>\n'}},35:function(s,n){s.exports={attributes:{Category:"Libft",Id:4,Title:"Libft : str function",Description:"mem function",Date:"2020, 10, 17 (Sat)",Auther:"seolim",pre:3,next:5},html:'<h1>Libft str function</h1>\n<blockquote>\n<p>Link</p>\n</blockquote>\n<p><a href="https://github.com/seo1im/Libft">https://github.com/seo1im/Libft</a></p>\n<blockquote>\n<p>Caution</p>\n</blockquote>\n<p>본 문서를 포함한 블로그의 모든 내용은 <b>42 innovation academy</b>의 과제의 작성자의 해석 및 풀이 등으로 이루어져 있습니다.</br>본인이 42 교육생이거나 42 교육을 희망하는 분이라면 글을 먼저 보기보다는 고민해보고 읽어보기를 추천드립니다.</p>\n<blockquote>\n<p>목적</p>\n</blockquote>\n<p>str 관련 함수들을 알아보자. 이번 과정에서 알아볼 함수들은 아래와 같다.</p>\n<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">strlen</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* str)</span></span>;\n\n<span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">strchr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* str, <span class="hljs-keyword">int</span> character)</span></span>;\n\n<span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">strrchr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* str, <span class="hljs-keyword">int</span> character)</span></span>;\n\n<span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">strlcpy</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* dst, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* src, <span class="hljs-keyword">size_t</span> size)</span></span>;\n\n<span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">strlcat</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* dst, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* src, <span class="hljs-keyword">size_t</span> size)</span></span>;\n</code></pre>\n<blockquote>\n<p>str 함수들</p>\n</blockquote>\n<p>str함수는 char 포인터를 조작하는 함수들이며 기본적으로는 <code>&lt;string.h&gt;</code>에 정의되어있다.(뒤에 서술하겠지만 <code>strlcat</code>, <code>strlcpy</code>는 bsd system에 추가된 함수이다. 따라서 os에 따라서 library를 include해야할 필요가 있다)</br></br>\nmem 함수와 size를 받지 않는데, 문자열은 반드시 null로 종료된다는 기준이 있기 때문이다. 따라서 마지막이 null로 끝나지 않는 char 포인터나 배열을 받으면 정상적으로 동작하지 않게 된다.</p>\n<h3>strlen</h3>\n<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">strlen</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* str)</span></span>;\n</code></pre>\n<table>\n    <tr>\n        <td class="title">str</td>\n        <td>문자열 첫 주소</td>\n    </tr>\n    <tr>\n        <td class="title">return</td>\n        <td>문자열의 길이</td>\n    </tr>\n</table>\n<p>문자열(str)의 총 길이를 반환한다. 문자열의 길이는 주소 시작점으로부터 null문자(0)를 만날 때까지 바이트수를 말한다.</p>\n<h3>strchr</h3>\n<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">strchr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* str, <span class="hljs-keyword">int</span> character)</span></span>;\n</code></pre>\n<table>\n    <tr>\n        <td class="title">str</td>\n        <td>문자열 첫 주소</td>\n    </tr>\n    <tr>\n        <td class="title">character</td>\n        <td>찾을 문자</td>\n    </tr>\n    <tr>\n        <td class="title">return</td>\n        <td>성공 : 찾은 문자의 주소 / 실패 : NULL</td>\n    </tr>\n</table>\n<p>문자열에서 특정한 문자가 가장 먼저 나타나는 곳의 위치를 찾는다.</p>\n<h3>strrchr</h3>\n<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">strrchr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* str, <span class="hljs-keyword">int</span> character)</span></span>;\n</code></pre>\n<table>\n    <tr>\n        <td class="title">str</td>\n        <td>문자열 첫 주소</td>\n    </tr>\n    <tr>\n        <td class="title">character</td>\n        <td>찾을 문자</td>\n    </tr>\n    <tr>\n        <td class="title">return</td>\n        <td>성공 : 찾은 문자의 주소 / 실패 : NULL</td>\n    </tr>\n</table>\n<p><code>strchr</code>과 마찬가지로 문자를 찾지만 가장 마지막으로 나타나는 위치를 찾는다.</p>\n<blockquote>\n<p>bsd function</p>\n</blockquote>\n<p><code>strlcat</code>과 <code>strlcpy</code>는 openBSD에 정의되어 있다.(OpenBSD에 대한 내용은 <a href="https://www.openbsd.org/">여기</a>) 이 둘은 BSD의 취지에 걸맞게 보안 목적으로 개발되었다.</br></br>os에 따라 compile에서 동작하지 않을 수 있는데 os상의 <code>bsd/string.h</code>의 위치를 확인하고 include하고 libs를 포함시켜야 할 수 있다.</p>\n<pre class="hljs"><code><span class="hljs-comment">/* 이는 하나의 example 이고 정상동작하지 않으면 bsd/string.h의 정확한 위치를 찾아야 한다 */</span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bsd/string.h&gt;</span></span>\n</code></pre>\n<pre class="hljs"><code>gcc *.c -lbsd\n</code></pre>\n<h3>strlcpy</h3>\n<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">strlcpy</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* dst, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* src, <span class="hljs-keyword">size_t</span> size)</span></span>;\n</code></pre>\n<table>\n    <tr>\n        <td class="title">dst</td>\n        <td>복사될 문자열 첫 주소</td>\n    </tr>\n    <tr>\n        <td class="title">src</td>\n        <td>복사할 문자열 첫 주소</td>\n    </tr>\n    <tr>\n        <td class="title">size</td>\n        <td>복사<span style="color : #b5251b"><b>될</b></span> 문자의 최종 길이</td>\n    </tr>\n    <tr>\n        <td class="title">return</td>\n        <td>복사된 문자열의 길이</td>\n    </tr>\n</table>\n<p>특정 문자열을 특정 문자열에 복사하는 함수이다.</br></br><code>strlcpy</code>를 보기전 <code>strcpy</code>살펴보자. <code>strcpy</code>는 source문자열을 destination에 복사하는 함수이다. 아래와 같은 상황에서 문제가 발생한다.</p>\n<pre class="hljs"><code><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">s_strs</span> {</span>\n    <span class="hljs-keyword">char</span> s1[<span class="hljs-number">5</span>];\n    <span class="hljs-keyword">char</span> s2[<span class="hljs-number">5</span>];\n}             t_strs;\n\nt_strs strs;\n\n<span class="hljs-built_in">strcpy</span>(strs.s2, <span class="hljs-string">&quot;12345&quot;</span>);\n<span class="hljs-built_in">strcpy</span>(strs.s1, <span class="hljs-string">&quot;12345678&quot;</span>);\n</code></pre>\n<p>위 코드에서 s2값을 확인해보면 값이 정상적이지 않음을 확인할 수 있을 것이다.(통상 67845가 출력될 것이다) 이는 strcpy는 메모리 영역을 그저 채우기만 하기 때문이다.</br>따라서 overflow된 값인 678이 이어져있던 buffer의 123을 덮어버리기 때문이다. 이러한 문제를 해결하기 위해 <code>strncpy</code>와 문자열의 크기를 정확히 알고 활용해야함에 주의를 둔다.</br></br><code>strncpy</code>도 문제가 발생할 수 있는데, 아래를 살펴보자</p>\n<pre class="hljs"><code><span class="hljs-keyword">char</span> src[] = <span class="hljs-string">&quot;tester&quot;</span>;\n<span class="hljs-keyword">char</span> dest[<span class="hljs-number">6</span>];\n\n<span class="hljs-built_in">strncpy</span>(dest, src, <span class="hljs-number">3</span>);\n</code></pre>\n<p>위 코드는 동작에 아무런 이상이 없을 것 같지만, 실제로는 dest가 null문자로 종료되었다는 보장이 없다. dest의 0, 1, 2 buffer에는 t, e, s가 각각 복사되었지만 3번째 buffer가 NULL이라는 보장이 없다. <code>strlcat</code>은 이러한 위험성을 최대한 배제하기 위해 만들어졌다.</br></br><code>strlcpy</code>는 복사<strong>될</strong>문자열의 NULL문자를 포함한 최종길이를 파라미터로 받는데, 반드시 마지막 문자는 NULL문자로 종료된다. 따라서 <code>strncpy</code>와 같은 문제가 발생하지 않는다.</p>\n<h3>strlcat</h3>\n<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">strlcat</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* dst, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* src, <span class="hljs-keyword">size_t</span> size)</span></span>;\n</code></pre>\n<table>\n    <tr>\n        <td class="title">dst</td>\n        <td>연결될 문자열 첫 주소</td>\n    </tr>\n    <tr>\n        <td class="title">src</td>\n        <td>연결할 문자열 첫 주소</td>\n    </tr>\n    <tr>\n        <td class="title">size</td>\n        <td>복사<span style="color : #b5251b"><b>될</b></span> 문자의 최종 길이</td>\n    </tr>\n    <tr>\n        <td class="title">return</td>\n        <td>연결된 문자열의 길이</td>\n    </tr>\n</table>\n<p>문자열에 특정 문자열을 정해진 길이까지 연결하는 함수이다.</br></br><code>strlcat</code>도 <code>strcat</code>의 overflow를 해결하기 위해 개발된 <code>strncat</code>의 null문자를 보완하기 위해 만들어졌다. <code>strlcat</code>은 규정된 방식에 따라 동작하는데 그 규칙을 명확히 해야 함수를 구현할 때 오류가 없이 동작하게끔 만들 수 있다. 예를 들어 size가 dest의 길이보다 작다면 아예 연결이 되지 않고 dest가 그대로 반환된다.</p>\n'}},36:function(s,n){s.exports={attributes:{Category:"Libft",Id:5,Title:"Libft : str function 2 / ctype function",Description:"str 함수들과 ctype의 is 함수들을 알아본다",Date:"2020, 10, 19 (Mon)",Auther:"seolim",pre:4,next:0},html:'<h1>Libft str function / ctype function</h1>\n<blockquote>\n<p>Link</p>\n</blockquote>\n<p><a href="https://github.com/seo1im/Libft">https://github.com/seo1im/Libft</a></p>\n<blockquote>\n<p>Caution</p>\n</blockquote>\n<p>본 문서를 포함한 블로그의 모든 내용은 <b>42 innovation academy</b>의 과제의 작성자의 해석 및 풀이 등으로 이루어져 있습니다.</br>본인이 42 교육생이거나 42 교육을 희망하는 분이라면 글을 먼저 보기보다는 고민해보고 읽어보기를 추천드립니다.</p>\n<blockquote>\n<p>목적</p>\n</blockquote>\n<p>str 관련 함수들와 ctype함수들을 알아보자. 이번 과정에서 알아볼 함수들은 아래와 같다.</p>\n<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">strnstr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *big, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *little, <span class="hljs-keyword">size_t</span> len)</span></span>;\n\n<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">strncmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* str1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* str2, <span class="hljs-keyword">size_t</span> num)</span></span>;\n\n<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isalpha</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span></span>;\n\n<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isdigit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span></span>;\n\n<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isalnum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span></span>;\n\n<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isascii</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span></span>;\n\n<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isprint</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span></span>;\n\n<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">toupper</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span></span>;\n\n<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">tolower</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span></span>;\n</code></pre>\n<blockquote>\n<p>str 함수들</p>\n</blockquote>\n<h3>strnstr</h3>\n<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">strnstr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *find, <span class="hljs-keyword">size_t</span> len)</span></span>;\n</code></pre>\n<table>\n    <tr>\n        <td class="title">str</td>\n        <td>탐색될 문자열의 첫번째 주소</td>\n    </tr>\n    <tr>\n        <td class="title">find</td>\n        <td>탐색할 문자열의 첫번째 주소</td>\n    </tr>\n    <tr>\n        <td class="title">len</td>\n        <td>탐색될 문자열의 길이</td>\n    </tr>\n    <tr>\n        <td class="title">return</td>\n        <td>성공 : 찾은 문자열의 시작 위치 / 실패 : NULL</td>\n    </tr>\n</table>\n<p>문자열(str)내에 특정 문자열(find)과 같은 첫번째 문자열을 찾는다. 성공할시 같은 문자열의 첫 주소를 반환한다. 아래와 같이 동작된다.</p>\n<pre class="hljs"><code><span class="hljs-keyword">char</span> str[] = <span class="hljs-string">&quot;Hello Hello World&quot;</span>;\n<span class="hljs-keyword">char</span> find[] = <span class="hljs-string">&quot;lo&quot;</span>\n\n<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;result : %s\\n&quot;</span>, strnstr(str, find, <span class="hljs-built_in">strlen</span>(str)));\n<span class="hljs-comment">/* result : lo Hello World */</span>\n</code></pre>\n<h3>strncmp</h3>\n<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">strncmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* str1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* str2, <span class="hljs-keyword">size_t</span> num)</span></span>;\n</code></pre>\n<table>\n    <tr>\n        <td class="title">str1</td>\n        <td>비교할 문자열</td>\n    </tr>\n    <tr>\n        <td class="title">str2</td>\n        <td>비교할 문자열</td>\n    </tr>\n    <tr>\n        <td class="title">num</td>\n        <td>비교할 길이</td>\n    </tr>\n    <tr>\n        <td class="title">return</td>\n        <td>동일 : 0 / 다름 : *str1 - *str2</td>\n    </tr>\n</table>\n<p>동작은 memcmp와 다를것이 없고 char 포인터만을 받는다는 점이 다르다.</p>\n<blockquote>\n<p>ctype function</p>\n</blockquote>\n<p>ctype에 정의된 함수들은 ascii문자를 검사, 조작하는 함수들이다.</br>대체로 <strong>is~</strong> 함수는 조건을 검사하는 함수들이고 <strong>to~</strong> 함수는 값을 조작하는 함수들이다.</p>\n<h3>isalpha / isdigit / isalnum / isascii / isprint</h3>\n<p>모두 int값을 범위로 받는데 받는 범위는 ascii에 정의된 0 ~ 127까지만 가능하다. 다만 운영체제에는 255번 ascii code가 있는데 이는 확장 ascii code(extended ascii code)로 표준으로 지정된 값은 아니다.</br></br>각각의 값의 범위는 아래와 같다.</p>\n<pre class="hljs"><code><span class="hljs-built_in">isalpha</span> : <span class="hljs-number">65</span> ~ <span class="hljs-number">90</span> / <span class="hljs-number">97</span> ~ <span class="hljs-number">122</span>\n\n<span class="hljs-built_in">isdigit</span> : <span class="hljs-number">48</span> ~ <span class="hljs-number">57</span>\n\n<span class="hljs-built_in">isalnum</span> : <span class="hljs-number">48</span> ~ <span class="hljs-number">57</span> / <span class="hljs-number">65</span> ~ <span class="hljs-number">90</span> / <span class="hljs-number">97</span> ~ <span class="hljs-number">122</span>\n\nisascii : <span class="hljs-number">0</span> ~ <span class="hljs-number">127</span>\n\n<span class="hljs-built_in">isprint</span> : <span class="hljs-number">32</span> ~ <span class="hljs-number">126</span>\n</code></pre>\n<p>모든 함수는 조건에 맞으면 1, 틀리면 0을 반환한다.</p>\n<h5>extende ascii code</h5>\n<p>extended ascii code는 7 bit(128개 문자) code의 표현 한계(모든 문자의 표기 불가)로 인해 8 bit로 확장된 코드이다. 다만 국가마다 넣어야 할 문자가 다른 문제로 인해 국가마다 그 영역이 다르기 때문에 정확한 표준이 아니며 여전히 표기법이 많은 문자에는 한계가 발생한다. 이에대해서 <strong>unicode</strong>가 등장하게 된다. 이 글에선 해당 내용은 생략한다.</p>\n<h3>toupper / tolower</h3>\n<p>각각 알파벳의 소문자를 대문자로, 대문자를 소문자로 바꾸는 함수이다. 해당되지 않는 문자는 그대로 반환된다.</p>\n'}},39:function(s,n,a){"use strict";a.r(n);var t=a(0),e=a.n(t),l=a(1),r=(a(7),a(27)),p=a(12);function c(){var s=v(["\n\ttext-decoration : none;\n\tcolor : ",";\n"]);return c=function(){return s},s}function o(){var s=v(["\n\tmargin : 0.5rem 0 0 0;\n\tfont-size : 1.1rem;\n"]);return o=function(){return s},s}function i(){var s=v(["\n\tbackground-color : white;\n\t\n\twidth : 10rem;\n\tmargin-top : 2rem;\n\tmargin-right : calc((100% - 65rem)/2);\n\tpadding-left : 1rem;\n\n\tfont-size : 1.5rem;\n\tcolor : #50c79f;\n\n\t@media only screen and (max-width: 60rem) {\n\t\tdisplay : none;\n\t}\n"]);return i=function(){return s},s}function d(){var s=v(["\n\tpadding-left : 1rem;\n\n\tmargin-left : 0.5rem;\n\tfont-size : 1rem;\n\tword-break : keep-all;\n"]);return d=function(){return s},s}function h(){var s=v(["\n\tpadding-left : 1rem;\n\tmargin-left : 0.3rem;\n\tmargin-bottom : 1rem;\n\tfont-size : 3rem;\n\tfont-weight : bold;\n"]);return h=function(){return s},s}function u(){var s=v(["\n\twidth : 3rem;\n\tmargin-right : 1rem;\n\tborder-radius : 1rem;\n"]);return u=function(){return s},s}function m(){var s=v(["\n\tdisplay : inline-block;\n\tmargin : 0 1rem 0 0;\n\tfont-size : 1.2rem;\n"]);return m=function(){return s},s}function j(){var s=v(["\n\tpadding : 2rem 1rem;\n"]);return j=function(){return s},s}function y(){var s=v(["\n\tbackground-color : white;\n\tborder-bottom : solid 0.01rem grey;\n\t\n\twidth : 48rem;\n\tmin-height : 15rem;\n\tmargin : 0 1rem;\n\tpadding-bottom : 2rem;\n\n\t@media only screen and (max-width: 60rem) {\n\t\twidth : calc(100% - 2rem);\n\t}\n"]);return y=function(){return s},s}function f(){var s=v(["\n\tbackground-color : white;\n\t\n\twidth : 50rem;\n\tmargin-left : calc((100% - 60rem) / 2);\n\t\n\t@media only screen and (max-width: 60rem) {\n\t\tmargin-left : 1.5rem;\n\t\tmargin-right : 1.5rem;\n\t\twidth : calc(100% - 3rem);\n\t}\n"]);return f=function(){return s},s}function b(){var s=v(["\n\tbackground-color : white;\n\tmargin-top : 3rem;\n\tdisplay :flex;\n\twidth : 100%;\n"]);return b=function(){return s},s}function k(){var s=v(["\n\tbackground-color : black;\n\n\twidth : 100%;\n\theight : 25rem;\n\tpadding-top : 3rem;\n\n\ttext-align : center;\n\tcolor : white;\n\tline-height : 25rem;\n\tfont-size : 5rem;\n"]);return k=function(){return s},s}function w(){var s=v(["\n\n"]);return w=function(){return s},s}function v(s,n){return n||(n=s.slice(0)),Object.freeze(Object.defineProperties(s,{raw:{value:Object.freeze(n)}}))}var g=r.a.div(w()),_=r.a.div(k()),z=r.a.div(b()),E=r.a.div(f()),q=r.a.div(y()),L=r.a.div(j()),O=r.a.p(m()),x=r.a.img.attrs({src:"https://raw.githubusercontent.com/seo1im/42BLOG/master/src/images/backSource/profile.jpg"})(u()),D=r.a.div(h()),S=r.a.div(d()),P=r.a.div(i()),C=r.a.p(o()),T=Object(r.a)(p.b)(c(),(function(s){return s.color})),R={categories:["Libft","get_next_line","netwhat","ft_printf"]};function B(s){return(B="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(s){return typeof s}:function(s){return s&&"function"==typeof Symbol&&s.constructor===Symbol&&s!==Symbol.prototype?"symbol":typeof s})(s)}function N(s,n){if(!(s instanceof n))throw new TypeError("Cannot call a class as a function")}function I(s,n){for(var a=0;a<n.length;a++){var t=n[a];t.enumerable=t.enumerable||!1,t.configurable=!0,"value"in t&&(t.writable=!0),Object.defineProperty(s,t.key,t)}}function U(s,n){return(U=Object.setPrototypeOf||function(s,n){return s.__proto__=n,s})(s,n)}function A(s){var n=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(s){return!1}}();return function(){var a,t=H(s);if(n){var e=H(this).constructor;a=Reflect.construct(t,arguments,e)}else a=t.apply(this,arguments);return G(this,a)}}function G(s,n){return!n||"object"!==B(n)&&"function"!=typeof n?function(s){if(void 0===s)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return s}(s):n}function H(s){return(H=Object.setPrototypeOf?Object.getPrototypeOf:function(s){return s.__proto__||Object.getPrototypeOf(s)})(s)}var M=function(s){var n=s.category;return e.a.createElement(_,null,n||"Seolim`s 42 BLOG")},F=function(s){var n=s.info;return e.a.createElement(q,null,e.a.createElement(L,null,e.a.createElement(x,null),e.a.createElement(O,null,n.Category),e.a.createElement(O,null,n.Date),e.a.createElement(O,null,n.Auther)),e.a.createElement(D,null,e.a.createElement(T,{exact:!0,to:"/Blog/".concat(n.Category,"/").concat(n.Id),color:"black"},n.Title)),e.a.createElement(S,null,e.a.createElement(T,{exact:!0,to:"/Blog/".concat(n.Category,"/").concat(n.Id),color:"black"},n.Description)))},J=function(s){var n=s.posts,a=s.category;return e.a.createElement(E,null,a?n.map((function(s,n){if(s.attributes.Category==a)return e.a.createElement(F,{info:s.attributes,key:n})})):n.map((function(s,n){return e.a.createElement(F,{info:s.attributes,key:n})})))},W=function(s){var n=s.categories;return e.a.createElement(P,null,e.a.createElement("b",null,"CATEGOTIES"),n.map((function(s,n){return e.a.createElement(C,{id:n},e.a.createElement(T,{exact:!0,to:"/Blog/".concat(s),color:"black"},s))})))},K=function(s){!function(s,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");s.prototype=Object.create(n&&n.prototype,{constructor:{value:s,writable:!0,configurable:!0}}),n&&U(s,n)}(r,s);var n,a,t,l=A(r);function r(){return N(this,r),l.apply(this,arguments)}return n=r,(a=[{key:"render",value:function(){var s=this.props.match.params.category,n=this.props,a=n.posts,t=n.information;return console.log(this.props),e.a.createElement(g,null,e.a.createElement(M,{category:s}),e.a.createElement(z,null,e.a.createElement(J,{posts:a,category:s}),e.a.createElement(W,{categories:t.categories})))}}])&&I(n.prototype,a),t&&I(n,t),r}(e.a.Component);K.propTypes={},K.defaultPros={};var Q=K;function V(){var s=es(["\n\ttext-decoration : none;\n\tfont-weight : bold;\n\tcolor : grey;\n"]);return V=function(){return s},s}function X(){var s=es(["\n\tbackground-color : #EDEDED;\n\tborder-right : solid 5px #40a899;\n\n\tposition : absolute;\n\tright : 3rem;\n\n\twidth : 10rem;\n\theight : 2.5rem;\n\tmargin-bottom : 3rem;\n\tpadding-left : 2rem;\n\n\tline-height : 2.5rem;\n"]);return X=function(){return s},s}function Y(){var s=es(["\n\tbackground-color : #EDEDED;\n\tborder-left : solid 5px #40a899;\n\n\tposition : absolute;\n\tleft : 3rem;\n\n\twidth : 10rem;\n\theight : 2.5rem;\n\tmargin-bottom : 3rem;\n\tpadding-left : 2rem;\n\n\tline-height : 2.5rem;\n"]);return Y=function(){return s},s}function Z(){var s=es(["\t\n\twidth : 60rem;\n\tmargin-top : 2rem;\n\tmargin-bottom : 5rem;\n\tmargin-left : calc((100% - 58rem) / 2);\n\tmargin-right : calc((100% - 58rem) / 2);\t\n\n\t@media only screen and (max-width: 60rem) {\n\t\tmargin-left : 2.5rem;\n\t\tmargin-right : 2.5rem;\n\t\twidth : calc(100% - 5rem);\n\t}\n"]);return Z=function(){return s},s}function $(){var s=es(["\n\twidth : 5rem;\n\tborder-radius : 70%;\n\toverflow: hidden;\n\tborder : solid 0.01rem black;\n"]);return $=function(){return s},s}function ss(){var s=es(["\n\tdisplay : inline-block;\n\tmargin : 2rem 0 2rem 2rem;\n"]);return ss=function(){return s},s}function ns(){var s=es(["\n\tmargin-left : 2rem;\n\tfont-size : 4rem;\n\tword-break : keep-all;\n"]);return ns=function(){return s},s}function as(){var s=es(["\n\tborder-bottom : solid 0.01rem grey;\n\n\twidth : 50rem;\n\tmargin-top : 3rem;\n\tpadding-top : 2rem;\n\tpadding-bottom : 1.5rem;\n\tmargin-left : calc((100% - 50rem) / 2);\n\tmargin-right : calc((100% - 50rem) / 2);\t\n\tmin-height : 10rem;\n\t\n\n\t@media only screen and (max-width: 50rem) {\n\t\tmargin-left : 1rem;\n\t\tmargin-right : 1rem;\n\t\twidth : calc(100% - 2rem);\n\t}\n"]);return as=function(){return s},s}function ts(){var s=es(["\n\t\n"]);return ts=function(){return s},s}function es(s,n){return n||(n=s.slice(0)),Object.freeze(Object.defineProperties(s,{raw:{value:Object.freeze(n)}}))}var ls=r.a.div(ts()),rs=r.a.div(as()),ps=r.a.div(ns()),cs=r.a.p(ss()),os=(r.a.img.attrs({src:"https://raw.githubusercontent.com/seo1im/42BLOG/master/src/images/backSource/profile.jpg"})($()),r.a.div(Z())),is=r.a.div(Y()),ds=r.a.div(X()),hs=Object(r.a)(p.b)(V());function us(s){return(us="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(s){return typeof s}:function(s){return s&&"function"==typeof Symbol&&s.constructor===Symbol&&s!==Symbol.prototype?"symbol":typeof s})(s)}function ms(s,n){if(!(s instanceof n))throw new TypeError("Cannot call a class as a function")}function js(s,n){for(var a=0;a<n.length;a++){var t=n[a];t.enumerable=t.enumerable||!1,t.configurable=!0,"value"in t&&(t.writable=!0),Object.defineProperty(s,t.key,t)}}function ys(s,n){return(ys=Object.setPrototypeOf||function(s,n){return s.__proto__=n,s})(s,n)}function fs(s){var n=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(s){return!1}}();return function(){var a,t=ks(s);if(n){var e=ks(this).constructor;a=Reflect.construct(t,arguments,e)}else a=t.apply(this,arguments);return bs(this,a)}}function bs(s,n){return!n||"object"!==us(n)&&"function"!=typeof n?function(s){if(void 0===s)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return s}(s):n}function ks(s){return(ks=Object.setPrototypeOf?Object.getPrototypeOf:function(s){return s.__proto__||Object.getPrototypeOf(s)})(s)}var ws=function(s){var n=s.link,a=s.str;return"Previous"===a?e.a.createElement(is,null,e.a.createElement(hs,{to:n},a)):e.a.createElement(ds,null,e.a.createElement(hs,{to:n},a))},vs=function(s){var n=s.info;return e.a.createElement(rs,null,e.a.createElement(cs,null,n.Category),e.a.createElement(cs,null,n.Date),e.a.createElement(cs,null,e.a.createElement("b",null,n.Auther)),e.a.createElement(ps,null,n.Title),e.a.createElement(cs,{style:{margin:"0.5rem 0 0 2.5rem"}},n.Description))},gs=function(s){var n=s.post;return e.a.createElement(os,null,e.a.createElement("div",{dangerouslySetInnerHTML:{__html:n.html},className:"markdown"}))},_s=function(s){!function(s,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");s.prototype=Object.create(n&&n.prototype,{constructor:{value:s,writable:!0,configurable:!0}}),n&&ys(s,n)}(r,s);var n,a,t,l=fs(r);function r(){return ms(this,r),l.apply(this,arguments)}return n=r,(a=[{key:"render",value:function(){var s=this.props.match.params,n=s.category,a=s.id,t=this.props.posts,l=t.filter((function(s){return s.attributes.Id==a&&s.attributes.Category==n}))[0];return l||(function(s){throw new Error('"'+s+'" is read-only')}("post"),l=t[0]),e.a.createElement(ls,null,e.a.createElement(vs,{info:l.attributes}),e.a.createElement(gs,{post:l}),0!==l.attributes.pre?e.a.createElement(ws,{link:"/Blog/".concat(l.attributes.Category,"/").concat(l.attributes.pre),str:"Previous"}):e.a.createElement("div",null),0!==l.attributes.next?e.a.createElement(ws,{link:"/Blog/".concat(l.attributes.Category,"/").concat(l.attributes.next),str:"Next"}):e.a.createElement("div",null))}}])&&js(n.prototype,a),t&&js(n,t),r}(e.a.Component);_s.propTypes={},_s.defaultPros={};var zs=_s,Es=a(32),qs=a.n(Es),Ls=a(33),Os=a.n(Ls),xs=a(34),Ds=a.n(xs),Ss=a(35),Ps=a.n(Ss),Cs=a(36),Ts=[a.n(Cs).a,Ps.a,Ds.a,Os.a,qs.a];function Rs(s){return(Rs="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(s){return typeof s}:function(s){return s&&"function"==typeof Symbol&&s.constructor===Symbol&&s!==Symbol.prototype?"symbol":typeof s})(s)}function Bs(s,n){if(!(s instanceof n))throw new TypeError("Cannot call a class as a function")}function Ns(s,n){for(var a=0;a<n.length;a++){var t=n[a];t.enumerable=t.enumerable||!1,t.configurable=!0,"value"in t&&(t.writable=!0),Object.defineProperty(s,t.key,t)}}function Is(s,n){return(Is=Object.setPrototypeOf||function(s,n){return s.__proto__=n,s})(s,n)}function Us(s){var n=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(s){return!1}}();return function(){var a,t=Gs(s);if(n){var e=Gs(this).constructor;a=Reflect.construct(t,arguments,e)}else a=t.apply(this,arguments);return As(this,a)}}function As(s,n){return!n||"object"!==Rs(n)&&"function"!=typeof n?function(s){if(void 0===s)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return s}(s):n}function Gs(s){return(Gs=Object.setPrototypeOf?Object.getPrototypeOf:function(s){return s.__proto__||Object.getPrototypeOf(s)})(s)}var Hs=function(s){!function(s,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");s.prototype=Object.create(n&&n.prototype,{constructor:{value:s,writable:!0,configurable:!0}}),n&&Is(s,n)}(p,s);var n,a,t,r=Us(p);function p(){return Bs(this,p),r.apply(this,arguments)}return n=p,(a=[{key:"render",value:function(){var s=this.props.match;return e.a.createElement("div",null,e.a.createElement(l.a,{exact:!0,path:s.path,render:function(s){var n=s.match;return e.a.createElement(Q,{match:n,posts:Ts,information:R})}}),e.a.createElement(l.a,{exact:!0,path:"".concat(s.path,"/:category"),render:function(s){var n=s.match;return e.a.createElement(Q,{match:n,posts:Ts,information:R})}}),e.a.createElement(l.a,{path:"".concat(s.path,"/:category/:id"),render:function(s){var n=s.match;return e.a.createElement(zs,{match:n,posts:Ts,information:R})}}))}}])&&Ns(n.prototype,a),t&&Ns(n,t),p}(e.a.Component);Hs.propTypes={},Hs.defaultPros={};n.default=Hs}}]);